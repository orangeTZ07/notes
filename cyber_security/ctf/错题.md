### 本文本包含作者在ctf网站中做错的题目
<details>
<summary>编号GFSJ0234，名称PHP2</summary>

- 首先我们访问index.phps，得到index.php的代码(这个php版本太老了，响应头里写着X-Powered-By: PHP/5.6.37，所以才有了phps这个老古董)
- index.php的代码：
```php
<?php
if("admin"===$_GET[id]) {
  echo("<p>not allowed!</p>");
  exit();
}

$_GET[id] = urldecode($_GET[id]);
if($_GET[id] == "admin")
{
  echo "<p>Access granted!</p>";
  echo "<p>Key: xxxxxxx </p>";
}
?>

Can you anthenticate to this website?
```
- 最开始的错误: 为什么这道题不能用id=0来绕过？另外，chromium浏览器在访问的时候都会自动进行一次urldecode，然后把decode之后的内容传给php吗？为什么这得进行两次php编码？

<details><summary>问题解答</summary>

这是一个经典的 PHP 弱类型比较与 URL 编码绕过的安全题目。我们来逐一分析你的疑问。

### 1. 为什么不能用 `id=0` 绕过？

在 PHP 中，使用 `==`（弱类型比较）时确实存在 `0 == "string"` 为真的情况（尤其是在 PHP 8.0 之前的版本）。但在这道题中，`id=0` 无法绕过，原因有二：

* **第一步的严格检查：** ```php
if("admin"===$_GET[id])
```
这里使用了 `===`（全等运算符）。如果你传入 `id=0`，PHP 会判断整数 `0` 不等于字符串 `"admin"`，虽然能过第一关，但重点在后面。

```


* **第二步的字符串比较：**
```php
if($_GET[id] == "admin")

```


即便这里是 `==`，如果你传入的是 `id=0`（在 URL 中其实是字符串 `"0"`），那么 `"0" == "admin"` 的结果是 **false**。
*只有当一边是数字类型，另一边是字符串时，PHP 才会尝试转换。但在 URL 传参中，所有的输入默认都是字符串。*

---

### 2. Chromium 浏览器会自动进行 `urldecode` 吗？

这是一个常见的误区。**浏览器不会“主动”帮你解码后再发给后端，它做的是“编码”。**

1. **浏览器端：** 当你在地址栏输入特殊字符（如空格、% 等）并回车时，浏览器为了符合 HTTP 传输规范，会将这些字符进行 **URL 编码**。
2. **Web 服务器/PHP 引擎：** 当 PHP 接收到请求并存入 `$_GET` 全局变量时，它会**自动进行一次透明的解码**。

**过程如下：**

* 用户输入：`%61`
* 传输中：`%61`
* PHP 接收 `$_GET['id']`：自动解码，此时变量值已变成 `"a"`。

---

### 3. 为什么需要“两次编码”才能绕过？

这道题的核心逻辑漏洞在于：**在已经自动解码的基础上，代码又手动调用了一次 `urldecode()`。**

我们来看看如何通过两次编码绕过第一步的 `admin` 检查：

1. **构造 Payload：** 我们对 `admin` 中的字符（比如 `a`）进行两次编码。
* `a` 的一次编码：`%61`
* `%61` 的再次编码：`%2561`（把 `%` 编码成 `%25`）


2. **绕过第一步检查：**
* 你传入 `?id=%2561dmin`。
* PHP 自动解码一次，得到 `$_GET['id']` 的值为 `%61dmin`。
* 判断：`"%61dmin" === "admin"` 结果为 **false**，顺利跳过 `exit()`。


3. **进入手动解码：**
* 代码执行：`$_GET[id] = urldecode("%61dmin");`
* 此时变量值变成了 `"admin"`。


4. **绕过第二步检查：**
* 判断：`"admin" == "admin"` 结果为 **true**，拿到 Key。



---

### 总结

这道题考察的是 **"Double URL Decoding"（二次编码绕过）**。

* **失败路径：** 直接传 `admin` -> 被第一个 `if` 拦截 -> `exit`。
* **成功路径：** 传 `%2561dmin` -> 绕过第一个 `if`（因为此时是字符串 `%61...`） -> 经过手动 `urldecode` 变回 `admin` -> 匹配第二个 `if` -> 拿到 Key。

**想试试看吗？你可以尝试把 `a` 换成其他字母的两次编码，效果是一样的。如果你对 PHP 的弱类型比较（Type Juggling）感兴趣，我可以为你展示一份 `==` 的对比表。**
</details>

<details><summary>自动解码相关知识点</summary>

这是一个非常深入的问题。简单来说：**不只是 `$_GET`，所有通过 HTTP 协议传输到 PHP 的标准输入数据，在被填充到超全局变量之前，PHP 解释器都会自动进行一层 URL 解码。**

### 1. 哪些变量会自动解码？

在 PHP 接收到请求时，以下超全局变量中的 **键（Key）** 和 **值（Value）** 都会被自动解码：

* **`$_GET`**: 获取 URL 查询字符串（Query String）中的参数。
* **`$_POST`**: 当 `Content-Type` 为 `application/x-www-form-urlencoded` 时（这是 HTML 表单的默认提交方式）。
* **`$_COOKIE`**: 存储在 HTTP 请求头中的 Cookie 数据。
* **`$_REQUEST`**: 默认包含上述三者的合集。

---

### 2. 为什么会有这种自动机制？

这是由 **RFC 3986 标准** 决定的。在 HTTP 传输中，非字母数字字符（如空格、中文字符、特殊符号）必须经过 URL 编码（Percent-encoding），否则会破坏 HTTP 报文的结构。

例如，当你在浏览器地址栏输入 `?name=Tom%20Wait` 时：

1. **浏览器**：将空格转换为 `%20`。
2. **网络传输**：传输的是 `name=Tom%20Wait`。
3. **PHP 引擎**：在脚本执行前，自动将 `%20` 转回空格。
4. **你的代码**：调用 `$_GET['name']` 得到的是 `"Tom Wait"`。

---

### 3. 哪些情况“不会”自动解码？

了解哪些地方**不解码**对安全研究（绕过 WAF 等）非常重要：

* **`$_SERVER['QUERY_STRING']`**: 这是一个原始字符串。如果你访问 `?id=%61`，`$_GET['id']` 是 `a`，但 `$_SERVER['QUERY_STRING']` 依然是 `id=%61`。
* **`$_SERVER['REQUEST_URI']`**: 包含原始的路径和参数，不会被解码。
* **`php://input` (Raw Post Data)**: 当你使用 `file_get_contents("php://input")` 获取原始 POST 数据时，它是未经过解码的原始报文（除非你自己调用 `urldecode()`）。
* **非标准 Content-Type**: 如果 POST 请求的类型是 `text/plain` 或 `application/json`，PHP 不会将数据填充到 `$_POST` 中，自然也不会有自动解码的过程。

---

### 4. 回到你的那道安全题

正因为 `$_GET` **已经自动解过一次码了**，代码里又写了一句：
`$_GET[id] = urldecode($_GET[id]);`

这导致了**二次解码（Double Decode）**漏洞。

* **第一次解码（PHP 自动）**：将 `%2561` 还原为 `%61`。
* **第二次解码（代码手动）**：将 `%61` 还原为 `a`。

这就是为什么攻击者可以通过“双重编码”来欺骗那些只检查一次字符串的防御逻辑。

**你想了解如何利用 `php://input` 或者 `$_SERVER` 绕过某些特定的安全过滤吗？**
</details>
</details>
